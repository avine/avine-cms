<?php
/* Copyright (C) 2008. All Rights Reserved. @license - Copyrighted Software. Author: Stéphane Francel */


// No direct access
defined( '_DIRECT_ACCESS' ) or die( 'Restricted access' );



class wcal
{
	protected	$config;

	protected	$session;

	const		EVENT_TMPL_PATH = '/components/com_wcal/tmpl/',
				EVENT_TMPL_FILE = 'tmpl_event.php'; # Path of the default template

	// Some constants relatives to the 'unique_id' generated by $this->getWeekEvents() method
	const		UID_SEP			= '-',
				UID_INPUT_ID_	= 'uid_';



	/*
	 * -------------
	 * Manage config
	 * -------------
	 */

	public function __construct()
	{
		global $db;
		$this->config = $db->selectOne('wcal_config, *');

		$this->session = new sessionManager(sessionManager::FRONTEND, 'wcal');
	}



	public function getConfig( $key = '' )
	{
		if ($key)
		{
			return $this->config[$key];	# String
		} else {
			return $this->config;		# Array
		}
	}



	public function dateMaxReached( $time = false )
	{
		$time or $time = time();

		$offset = 60*60*24; # Add 24h because the day itself ends at 03:00 AM (see $this->mkTime() method for more details)

		if ( $this->config['date_max'] && ($time > $this->config['date_max']+$offset) )
		{
			return true;
		} else {
			return false;
		}
	}



	/*
	 * --------------
	 * Manage week_id
	 * --------------
	 */

	/*
	 * This method is designed for debugging : overwrite the value of $this->config['wday_sunday_7']
	 * Tips : to unset the global variable set $bool parameter at NULL
	 */
	static public function setLocaleWdaySunday7( $bool )
	{
		$GLOBALS['wcal_wday_sunday_7'] = $bool;
	}



	static public function wdaySunday7()
	{
		// Debugging mode : overwrite the value of $this->config['wday_sunday_7'] to what you need
		if (isset($GLOBALS['wcal_wday_sunday_7'])) {
			return $GLOBALS['wcal_wday_sunday_7'];
		}

		/**
		 * IMPORTANT SETTING
		 * -----------------
		 *
		 * Set if sunday have the index 0 (like in getdate() function) or 7.
		 *
		 * The consequence of this setting will be the range of the 'wday' field in the 'wday_event' table :
		 *		- from monday to sunday (when sunday = 7) : 1,2,3,4,5,6,7
		 *		- from sunday to saturday (when sunday = 0) : 0,1,2,3,4,5,6
		 *
		 * For temporary debugging, use the method wcal::setLocaleWdaySunday7() to overwrite the constant value.
		 * But you need to understand exactly what you are doing...
		 */
		global $db;
		$db->selectOne('wcal_config, wday_sunday_7', 'wday_sunday_7') ? $wday_sunday_7 = true : $wday_sunday_7 = false;

		// Production mode : return the real value
		return $wday_sunday_7;
	}



	static public function getWeekTimeRef()
	{
		if (self::wdaySunday7())
		{
			// The week range is : from monday to sunday
			return self::mkTime(1,5,1970);					# Lundi 5 janvier 1970 à 03h00 du matin !
		} else {
			// The week range is : from sunday to saturday
			return self::mkTime(1,4,1970);					# Dimanche 4 janvier 1970 à 03h00 du matin !
		}
	}



	static public function getWeekID( $time = NULL )
	{
		$offset = 60*60; # This 1 hour offset is necessary, but i did not make the mathematics... (Fully tested and works fine. Trust me on this !)

		return intval( (($time ? $time : time()) - self::getWeekTimeRef() + $offset) / (60*60*24*7) ); # 60*60*24*7 = 7 days
	}



	static public function getWeekTime( $week_id, $end_period = false )
	{
		$date = self::getDate( $week_id * (60*60*24*7) + self::getWeekTimeRef() ); # 60*60*24*7 = 7 days

		if ($end_period)
		{
			if (self::wdaySunday7())
			{
				// Overwrite the week-day from monday to the next sunday !
				$date['mday'] += 7 - $date['wday'];
			} else {
				// Overwrite the week-day from sunday to the next saturday !
				$date['mday'] += 6 - $date['wday'];
			}
		}

		return self::mkTime($date['mon'],$date['mday'],$date['year']);
	}



	static public function getWeekRange( $time )
	{
		$week_id = self::getWeekID($time);

		$time_begin	= getTime(self::getWeekTime($week_id,0), 'time=no;format=long');
		$time_end	= getTime(self::getWeekTime($week_id,1), 'time=no;format=long');

		return LANG_COM_WCAL_WEEK.' '.LANG_COM_WCAL_FROM." $time_begin ".LANG_COM_WCAL_TO." $time_end";
	}



	// Customized version of the getdate() PHP core function
	static public function getDate( $time )
	{
		$date = getdate($time);

		if (self::wdaySunday7())
		{
			// $date['wday'] from 1 (monday) to 7 (sunday) : 1,2,3,4,5,6,7
			$date['wday'] != 0 or $date['wday'] = 7; # Overwrite : from now the index of sunday is 7 (instead of 0)
		} else {
			// $date['wday'] from 0 (sunday) to 6 (saturday) : 0,1,2,3,4,5,6
			# Nothing to do, because it's exactly the behaviour of the getdate() function
		}

		return $date;
	}



	// Customized version of the mktime() PHP core function
	static public function mkTime( $mon = null, $mday = null, $year = null )
	{
		return mktime(3,0,0, $mon,$mday,$year); # Fixed at 03:00 AM !
	}



	// This method is designed to check the differents behaviours of this class
	static public function unitTest()
	{
		echo '<h1>UNIT TEST of wcal class</h1>';

		echo '<table style="width:99%;"><tr>';
		for ($wday_sunday_7=0; $wday_sunday_7<=1; $wday_sunday_7++)
		{
			echo '<td style="border:2px solid #ccc; padding:10px;">';

			self::setLocaleWdaySunday7($wday_sunday_7);

			if ($wday_sunday_7 == 0)
			{
				echo "<h2>In the table 'wcal_config', the field 'wday_sunday_7' = false</h2>";
			} else {
				echo "<h2>In the table 'wcal_config', the field 'wday_sunday_7' = true</h2>";
			}

			echo '<h3>Time reference :</h3><p>'.getTime(self::getWeekTimeRef(), 'format=long').'</p>';

			echo '<h3>wcal::wdayOptions() :</h3>';
			alt_print_r(self::wdayOptions(0));

			$wid = self::getWeekID();
			echo "<h3>ID of the current week :</h3><p>$wid</p>";
			echo	'<h3>Range of the current week :</h3><p><strong>From :</strong> '.
					getTime(self::getWeekTime($wid, 0), 'format=long').' <br /><strong>To :</strong> '.
					getTime(self::getWeekTime($wid, 1), 'format=long').'</p>';

			echo '<h3>Return of the method self::getDate() for :<br /> Dimanche 7 août 2011 <br /><span>(notice the value of the index [wday])</span></h3>';
			alt_print_r(self::getDate( self::mkTime(8,7,2011) )); # Dimanche 7 août 2011

			echo '</td>';
		}
		echo '</tr></table>';

		self::setLocaleWdaySunday7(NULL);
	}



	/*
	 * ----------------
	 * Manage period_id
	 * ----------------
	 */

	// Find the associated period_id of any time
	static public function findPeriodID( $time )
	{
		$wid = self::getWeekID($time);

		$default_pid = 1;

		// Special period
		global $db;
		$period_id = $db->selectOne("wcal_period, id, where: id!=$default_pid AND, where: wid_begin <= $wid AND, where: wid_end >= $wid", 'id');

		// Default period
		$period_id or $period_id = $default_pid;

		return $period_id;
	}



	/*
	 * This is the symetric of $this->findPeriodID() method.
	 * This method is designed to return the middle-time of a particular period.
	 * In case, the default period is requested, the method returns the time-reference
	 */
	static public function findTimeInsidePeriodID( $period_id )
	{
		if ($period_id != 1)
		{
			global $db;
			if ($period = $db->selectOne("wcal_period, wid_begin, wid_end, where: id=$period_id"))
			{
				$time_begin	= self::getWeekTime($period['wid_begin']);
				$time_end	= self::getWeekTime($period['wid_end'],1);

				// Middle time of the period
				$time = $time_begin + intval(($time_end - $time_begin)/2);
			}
			else
			{
				// No such period_id !
				trigger_error("Invalid \$period_id=$period_id in ".__METHOD__);
				return false;
			}
		}
		else
		{
			// We assume that the time-reference is associated to the default period (period_id=1)
			$time = self::getWeekTimeRef();
		}

		return $time;
	}



	/*
	 * ---------------
	 * Manage calendar
	 * ---------------
	 */

	/**
	 * Get the calendar as an array of datas
	 *
	 * @param string $param_type Set the type of $param 'period_id' or 'time'
	 * @return array $datas = array( 'header'=>array() , 'content'=>array() )
	 */
	public function getWeekEvents( $param = false, $param_type = 'period_id' )
	{
		if ($this->dateMaxReached())
		{
			return false;
		}

		switch ($param_type)
		{
			case 'period_id':
				$param ? $period_id = $param : $period_id = 1;	# Specified period_id or the default one
				break;

			case 'time':
				$param ? $time = $param : $time = time();		# Specified time of the default one
				$period_id = self::findPeriodID($time);
				break;

			default:
				trigger_error("Invalid \$param_type=$param_type in ".__METHOD__.". Expected 'period_id' or 'time'.");
				return NULL;
		}

		// Period events
		global $db;
		$event = $db->select("wcal_event, id AS event_id, wday(asc), time_begin(asc), time_end, category_id, where: period_id=$period_id");

		// Special offset (see below fore more details)
		self::wdaySunday7() ? $offset = 0 : $offset = 1;

		// Absolute week id
		!isset($time) or $week_id = self::getWeekID($time);

		// Array of seven columns (one for each day of the week) we want to fill with the events...
		$week_events = array();
		$i = 0;
		for ($wday=1-$offset; $wday<=7-$offset; $wday++)
		{
			// Be sure the $week_events array is begining from the index 0
			$j = $wday-(1-$offset); # $j = 0,1,2,3,4,5,6

			while(isset($event[$i]) && ($event[$i]['wday'] == $wday))
			{
				// In case $time was specified as $param, add unique id "week_id-event_id" to this event
				!isset($time) or $event[$i]['unique_id'	] = $week_id .self::UID_SEP. $event[$i]['event_id'];

				// Format time_*
				$event[$i]['time_begin'	] = $this->timeDBtoHTML($event[$i]['time_begin'	]);
				$event[$i]['time_end'	] = $this->timeDBtoHTML($event[$i]['time_end'	]);

				// Details of the current $wday event
				$week_events[$j][] = array_merge($event[$i], self::categoryDetails($event[$i]['category_id']));

				$i++;
			}

			// Add empty array when there's no event for this $wday
			isset($week_events[$j]) or $week_events[$j] = array();
		}

		// days-list and week-events in array format
		$datas =
			array(
				'header'	=> array_values(self::wdayOptions(false)),
				'content'	=> $week_events
			);

		return $datas;
	}



	// Get infos from 'wcal_category' table (and more...)
	static public function categoryDetails( $category_id = false )
	{
		static $category;
		if (!isset($category))
		{
			global $db;
			$category = $db->select("wcal_category, *, [id], category_order(asc)");

			$com_content = comContent_frontendScope();

			foreach($category as $id => $details)
			{
				if ($category[$id]['color']) {
					$category[$id]['color'] = '#'.$category[$id]['color'];
				}

				if ($category[$id]['node_id'])
				{
					$link = $com_content->nodeUrlEncoder($category[$id]['node_id']);
					if ($com_content->pageUrlRequest())
					{
						$href = comMenu_rewrite($com_content->pageUrlRequest().'&amp;'.$link['href']);
					} else {
						$href = comMenu_rewrite($link['href']);
					}
					$category[$id]['node_href'] = $href;
					$category[$id]['node_link'] = '<a href="'.$href.'">'.$link['value'].'</a>';
				}
			}
		}

		if ($category_id)
		{
			return $category[$category_id];	# Sub-array
		} else {
			return $category;				# Full-array
		}
	}



	/*
	 * Localize the index of a week-day in the $datas array (which is returned by $this->getWeekEvents() method)
	 *
	 * Example of use :
	 * ----------------
	 *
	 * // Some time
	 * $time = time();
	 *
	 * // Get $datas for this $time
	 * $datas = $this->getWeekEvents($time, 'time');
	 *
	 * // Show calendar with highlighted column for the day of $time !
	 * $this->showWeekEvents($datas, false,false, $this->wdayIndexInDatas($time) )
	 *
	 * So, you can see in the previous example that this method is designed to localize the index of a week-day in the $datas array
	 */
	static public function wdayIndexInDatas( $time )
	{
		$date = self::getDate($time);

		self::wdaySunday7() ? $offset = 1 : $offset = 0;

		return $date['wday']-$offset;
	}



	/**
	 * Slice datas returned by $this->getWeekEvents() method
	 */
	static public function sliceDatas( &$datas, $slice )
	{
		if (!$slice) {
			return;							# Keep all items
		}

		if ($slice > 0)
		{
			$abs = $slice;
			$index = array(0,$slice);		# Keep $slice items from the begining
		} else {
			$abs = -$slice;
			$index = array($slice,-$slice);	# Keep $slice items from the end
		}

		if ($abs >= 7) {
			trigger_error("Invalid \$slice=$slice parameter. Expected values : -6, -5, ..., 1,2, ... 5,6");
			return;
		}

		$datas =
			array(
				'header'	=> array_slice($datas['header'	], $index[0], $index[1]),
				'content'	=> array_slice($datas['content'	], $index[0], $index[1])
			);
	}



	/**
	 * Merge datas returned by $this->getWeekEvents() method
	 */
	static function mergeDatas( $datas1, $datas2 )
	{
		$datas =
			array(
				'header'	=> array_merge($datas1['header'	], $datas2['header'	]),
				'content'	=> array_merge($datas1['content'], $datas2['content'])
			);

		return $datas;
	}



	/**
	 * For each event, if 'node_id' specified in the category, then add a checkbox to the event to allow the dedication
	 * Add checkboxes for each event using the 'unique_id' info (if available)
	 *
	 * @param array $datas The return of $this->showWeekEvents() method
	 * @param string $form_id
	 * @param boolean $update
	 * @param integer $highlight The default value is false to disable the feature
	 */
	static public function addCheckboxesToDatas( &$datas, $form_id, $highlight = false )
	{
		$form = new formManager();
		$form->setForm('post', $form_id);

		for ($i=0; $i<count($datas['content']); $i++)
		{
			$i==$highlight ? $checked = 1 : $checked = 0;

			for ($j=0; $j<count($datas['content'][$i]); $j++)
			{
				$content = $datas['content'][$i][$j]; # Alias

				if (isset($content['unique_id']) && isset($content['node_id']))
				{
					$name = wcal::UID_INPUT_ID_.$content['unique_id'];

					$datas['content'][$i][$j]['checkbox'] = $form->checkbox($name, $checked);
					$datas['content'][$i][$j]['label'	] = $form->label($name, $content['title'].'<br />');
				}
			}
		}
	}



	/**
	 * @param array $datas The return of $this->getWeekEvents() method
	 * @param int $slice Show only a n slices of the $datas, from the begining or from the end
	 */
	public function showWeekEvents( $datas, $tmpl_name = '', $slice = false, $highlight = false )
	{
		$header		= $datas['header'	];
		$content	= $datas['content'	];

		$header_html = '';
		for ($i=0; $i<count($header); $i++)
		{
			($highlight!==false && $i==$highlight) ? $class = ' class="current"' : $class = '';

			$header_html .= "<th$class>{$header[$i]}</th>";
		}
		$header_html = "<tr>$header_html</tr>\n";

		$content_html = '';
		for ($i=0; $i<count($content); $i++)
		{
			($highlight!==false && $i==$highlight) ? $class = ' class="current"' : $class = '';

			$content_html .= "<td$class>";
			for ($j=0; $j<count($content[$i]); $j++)
			{
				if ($highlight!==false) {
					$i==$highlight ? $content[$i][$j]['current'] = true : $content[$i][$j]['current'] = false;
				}

				$content_html .= self::categoryTmpl($content[$i][$j], $tmpl_name);
			}
			$content_html .= "</td>";
		}
		$content_html = "<tr>$content_html</tr>\n";

		return "\n<table class=\"wcal-table\">\n$header_html{$content_html}</table>\n";
	}



	static public function categoryTmpl( $category, $tmpl_name = '' )
	{
		// Default file ?
		$tmpl_name or $tmpl_name = self::EVENT_TMPL_FILE;

		// Add path
		$tmpl_path = sitePath().self::EVENT_TMPL_PATH.$tmpl_name;

		$template = new templateManager();
		return $template->setTmplPath($tmpl_path)->setReplacements($category)->process();
	}



	/*
	 * Manage select form for category, period, ...
	 */

	static public function categoryOptions()
	{
		$options['root'] = LANG_SELECT_OPTION_ROOT;

		global $db;
		$category = $db->select('wcal_category, id, title(asc), author');
		for ($i=0; $i<count($category); $i++)
		{
			$options[$category[$i]['id']] = $category[$i]['title'];

			if ($category[$i]['author'])
			{
				$options[$category[$i]['id']] .= " ({$category[$i]['author']})";
			}
		}

		return $options;
	}



	static public function periodOptions( $online = true )
	{
		$options = array(); # Notice : here, no root option necessary.

		$period = self::periodDetails();
		foreach ($period as $id => $infos)
		{
			if (!$online || $infos['online'])
			{
				$options[$id] = $infos['title']. " ({$infos['validity']})";
			}
		}

		return $options;
	}



	// Get details of a particular period
	static public function periodDetails( $period_id = false, $key = false )
	{
		static $period;
		if (!isset($period))
		{
			$current_wid = self::getWeekID();

			global $db;
			$period = $db->select('wcal_period, *, [id], wid_begin(asc)');

			foreach ($period as $id => $infos)
			{
				if ($id != 1)
				{
					for ($i=0; $i<=1; $i++)
					{
						$i ? $format = 'long' : $format = 'short';
						$from	= LANG_COM_WCAL_FROM.' '.getTime(self::getWeekTime($infos['wid_begin']), "time=no;format=$format");
						$to		= LANG_COM_WCAL_TO	.' '.getTime(self::getWeekTime($infos['wid_end'],1), "time=no;format=$format");
						$period[$id]['validity'.($i ? '_long' : '')] = "$from $to";
					}

					($infos['wid_end'] < $current_wid) ? $period[$id]['online'] = false : $period[$id]['online'] = true;
				} else {
					$period[$id]['validity'] = $period[$id]['validity_long'] = LANG_COM_WCAL_DEFAULT_PERIOD_VALIDITY;

					$period[$id]['online'] = true;
				}
			}
		}

		if (!$period_id) {
			return $period;
		}
		elseif (!$key) {
			return $period[$period_id];
		}
		else {
			return $period[$period_id][$key];
		}
	}



	static public function wdayOptions( $root_option = true )
	{
		if ($root_option) {
			$options['root'] = LANG_SELECT_OPTION_ROOT;
		}

		// Alias
		$ref = self::getWeekTimeRef();
		$day = 60*60*24;

		self::wdaySunday7() ? $offset = 0 : $offset = 1;

		// Fill options
		for ($i=1-$offset; $i<=7-$offset; $i++)
		{
			$options[strval($i)] = ucfirst( strftime( '%A', $ref + $day*($i-(1-$offset)) ) );
		}

		return $options;
	}



	static public function dedicateTypeOptions( $root_option = true, $strip_tags = false )
	{
		if ($root_option) {
			$options[''] = LANG_SELECT_OPTION_ROOT;
		}

		global $db;
		$type = $db->select('wcal_dedicate_type, id, title(asc)');

		for ($i=0; $i<count($type); $i++)
		{
			!$strip_tags or $type[$i]['title'] = strip_tags($type[$i]['title']);
			$options[$type[$i]['id']] = $type[$i]['title'];
		}

		return $options;
	}



	/*
	 * Manage time
	 */

	static public function timeHTMLtoDB( $time )
	{
		$time = preg_replace('~[^0-9]~', ':', $time);
		$t = explode(':', $time);

		// No separator between HH and MM
		if (count($t) == 1 && formManager_filter::isInteger($time))
		{
			switch(strlen($time))
			{
				case 1:
					$return = '0'.$time.'00';
					break;

				case 2:
				case 3:
				case 4:
					$return = sprintf('%-04s', $time);
					break;
			}
		}
		elseif (count($t) == 2 && formManager_filter::isInteger($t[0]) && formManager_filter::isInteger($t[1]))
		{
			$return = sprintf('%02s', $t[0]).sprintf('%02s', $t[1]);
		}

		// Check the result
		if (isset($return))
		{
			$t = str_split($return, 2);
			if ( $t[0] <= 23 && $t[1] <= 59 ) {
				return $return;
			}
		}

		return false;
	}



	static function timeDBtoHTML( $time )
	{
		if ($time)
		{
			$t = str_split($time, 2);
			return $t[0].':'.$t[1]; # HH:MM
		}

		return '';
	}



	static function timeDBtoArray( $time )
	{
		if (!$time) {
			trigger_error('Empty $time not allowed in '.__METHOD__);
			return false;
		}

		$parts = str_split($time, 2);

		// Add simple alias
		$parts['hours'	] = $parts[0];
		$parts['minutes'] = $parts[1];

		/*
		 * Example : assuming time is 15h30
		 * $parts = array( 0=>15 , 1=>30 , 'hours'=>15 , 'minutes'=>30 );
		 */
		return $parts;
	}



	/*
	 * Manage color
	 */

	static public function eventBgStyle( $color = '', $css_addon = '', $style_addon = '' )
	{
		return " class=\"wcal-event $css_addon\" style=\"background-color:$color; $style_addon\" ";
	}



	/*
	 * Manage dedicate
	 */

	/**
	 * Analyse a list of 'unique_id' string generated by $this->getWeekEvents() method
	 * @param array $unique_id
	 */
	static public function dedicateDetailsFromUniqueID( $unique_id, $node_id_required = true )
	{
		$dedicate_details = array();

		for ($i=0; $i<count($unique_id); $i++)
		{
			// Get and validate the format of the week_id and the event_id
			$uid = explode(self::UID_SEP, $unique_id[$i]);
			$week_id	= $uid[0];
			$event_id	= $uid[1];
			if (!formManager_filter::isInteger($week_id) || !formManager_filter::isInteger($event_id)) {
				continue;
			}

			// Get the time from week_id and check that we have an event in 'wcal_event' table
			$time = self::getWeekTime($week_id);
			global $db;
			$event = $db->selectOne("wcal_event, *, where: id=$event_id");
			if (!$event) {
				continue;
			}

			// Check the founded 'event' have a 'node_id' associated to it
			$category = self::categoryDetails($event['category_id']);
			if ($node_id_required && !$category['node_id']) {
				continue;
			}

			// Get the real time of the begining of the event
			self::wdaySunday7() ? $offset = 1 : $offset = 0;
			$date = getDate($time + (60*60*24)*($event['wday']-$offset));
			$t = self::timeDBtoArray($event['time_begin']);
			$time = mktime($t['hours'],$t['minutes'],0, $date['mon'], $date['mday'], $date['year']);

			// Add dedicate
			$dedicate_details[] = array( 'node_id' => $category['node_id'], 'elm_date_creation' => $time );
		}

		return $dedicate_details;
	}



	/**
	 * After inserting a row in 'wcal_dedicate' table, you need to associate the inserted dedicate_id to the user of the current session
	 */
	public function sessionAddDedicateID( $dedicate_id )
	{
		$list = $this->session->get('dedicate_id', array());

		if (!in_array($dedicate_id, $list))
		{
			array_push($list, $dedicate_id);
			$this->session->set('dedicate_id', $list);
		}
	}



	/**
	 * Get the list of dedicate_id associated to the user of the current session
	 */
	public function sessionGetDedicateID()
	{
		return $this->session->get('dedicate_id', array());
	}



	public function sessionDeleteDedicateID( $id )
	{
		$new = array();

		$old = $this->session->get('dedicate_id', array());
		for ($i=0; $i<count($old); $i++)
		{
			($old[$i] == $id) or $new[] = $old[$i];
		}

		$this->session->set('dedicate_id', $new);
	}



	public function sessionReset()
	{
		$this->session->reset();
	}



	static public function dedicateDetails( $id )
	{
		global $db;
		if ($dedicate = $db->selectOne("wcal_dedicate, *, where: id=$id"))
		{
			$dedicate['details'] =
				$db->fetchMysqlResults(
					$db->sendMysqlQuery(
						"SELECT d.`id`, d.`node_id`, d.`elm_date_creation`, c.`title` FROM `{table_prefix}wcal_dedicate_details` AS d ".
						"LEFT JOIN `{table_prefix}content_node_item` AS c ON d.`node_id`=c.`node_id` ".
						"WHERE d.`dedicate_id`=$id ".
						"ORDER BY d.`elm_date_creation`"
					)
				);

			return $dedicate;
		}

		return false;
	}



	public function dedicateSummary()
	{
		$html = '';

		$dedicate_id = $this->session->get('dedicate_id');
		if (!$dedicate_id) {
			return false;
		}

		// Get list of dedicate type
		$type = self::dedicateTypeOptions(false);

		// Currency details
		$amount_total = 0;
		$this->amountCurrency($currency_code, $currency_name);

		for ($i=0; $i<count($dedicate_id); $i++)
		{
			$array = array(); # init

			$dedicate = self::dedicateDetails($dedicate_id[$i]);

			$id = $dedicate['id']; # Alias
			$update = '<a class="wcal-summary-upd" href="'. comMenu_rewrite('com=wcal&page=dedicate'). "?upd=$id". '">'.LANG_BUTTON_UPDATE. '</a>';
			$delete = '<a class="wcal-summary-del" href="'. comMenu_rewrite('com=wcal&page=summary'	). "?del=$id". '">'.LANG_BUTTON_DELETE. '</a>';
			$array[] = array( LANG_COM_WCAL_SUMMARY_ACTIONS, "$update $delete" );

			$array[] = array( LANG_COM_WCAL_DEDICATE_EVENT_DATE, ucfirst(getTime($dedicate['event_date'], 'format=long;time=no')) );
			$array[] = array( LANG_COM_WCAL_DEDICATE_TYPE, $type[$dedicate['type_id']] );

			$events = '';
			for ($j=0; $j<count($dedicate['details']); $j++) {
				$details = $dedicate['details'][$j]; # Alias
				$events .= $details['title'].' - '.getTime($details['elm_date_creation'], 'format=long').'<br />';
			}
			$array[] = array( LANG_COM_WCAL_SUMMARY_DEDICATED_EVENTS, $events );

			$array[] = array( LANG_COM_WCAL_DEDICATE_COMMENT, $dedicate['comment'] );

			$amounts = $this->amountEvents(count($dedicate['details']), true);
			$amount_total += $amounts[count($dedicate['details'])];
			$array[] = array( LANG_COM_WCAL_SUMMARY_AMOUNT, $amounts[count($dedicate['details'])]." $currency_name" );

			for ($j=0; $j<count($array); $j++) {
				$array[$j][0] = "<strong>{$array[$j][0]}</strong>";
			}

			$table = new tableManager($array);
			$html .= $table->html();
		}

		$html .= "\n<h2>".LANG_COM_WCAL_DEDICATE_AMOUNT_TOTAL." : <span>$amount_total $currency_name</span></h2>\n";

		return $html;
	}



	public function dedicateSummaryDelete()
	{
		if ($session = $this->sessionGetDedicateID())
		{
			if (isset($_GET['del']))
			{
				$del = (int) $_GET['del'];

				if (in_array($del, $session))
				{
					global $db;
					$db->delete("wcal_dedicate_details; where: dedicate_id=$del");
					$db->delete("wcal_dedicate; where: id=$del");
					$this->sessionDeleteDedicateID($del);
				}
			}
		}
	}



	public function dedicateSummaryUpdate()
	{
		if ($session = $this->sessionGetDedicateID())
		{
			if (isset($_GET['upd']))
			{
				$upd = (int) $_GET['upd'];

				if (in_array($upd, $session))
				{
					return $upd;
				}
			}
		}
	}



	/*
	 * Manage the dedicate amount
	 */

	public function amountEvents( $events_max = 99, $amount_units = false )
	{
		$cumulative = array(0);

		$amounts = explode(';', $this->getConfig('dedicate_amounts'));
		$amounts_last = $amounts[count($amounts)-1];

		if ($amount_units)
		{
			for ($i=0; $i<count($amounts); $i++) {
				$amounts[$i] = money::convertAmountCentsToUnits($amounts[$i]);
			}
			$amounts_last = money::convertAmountCentsToUnits($amounts_last);
		}

		$total = 0;
		for ($i=0; $i<$events_max; $i++)
		{
			isset($amounts[$i]) ? $total += $amounts[$i] : $total += $amounts_last;

			$cumulative[] = $total;
		}

		return $cumulative;
	}



	static public function amountCurrency( &$currency_code, &$currency_name )
	{
		// The currency code is defined by the com_donate component
		$donate = new comDonate_();
		$currency_code = $donate->currencyCode();

		// The associated currency name is defined in the money class
		$currency_name = money::currencyCodeOptionsPlural();
		$currency_name = mb_strtolower($currency_name[$currency_code]);
	}



	/*
	 * Be up to date and ready to checkout the dedicates payment
	 */

	public function manageDonateHandledDesignation()
	{
		$designation_id = $this->getConfig('handle_designation_id');
		if (!$designation_id) {
			trigger_error('<b>handle_designation_id</b> is missing in '.__METHOD__);
			return;
		}

		$dedicate_id = $this->sessionGetDedicateID();
		$donate = new comDonate_();
		if (!$dedicate_id) {
			$donate->handleDesignationReset();
			return;
		}

		global $db;

		// Init the donate session
		$donate->sessionBegin();
		$donate_id = $donate->sessionGetDonateID();

		// Get list of dedicate type
		$type = wcal::dedicateTypeOptions(false);

		// Here what we are looking for...
		$amount_total = 0;
		$short_description = '';

		// So, let's go !
		for ($i=0; $i<count($dedicate_id); $i++)
		{
			// Associate each dedicate to the donate of the session
			$db->update("wcal_dedicate; donate_id=$donate_id; where: id=".$dedicate_id[$i]);

			// Get the dedicate details
			$dedicate = wcal::dedicateDetails($dedicate_id[$i]);

			// Amount
			$amounts = $this->amountEvents(count($dedicate['details']));
			$amount_total += $amounts[count($dedicate['details'])];

			// Description
			$short_description .=
				ucfirst(getTime($dedicate['event_date'], 'format=long;time=no')).
				' - '.$type[$dedicate['type_id']].
				' ('.count($dedicate['details']).' cours)<br />';
		}

		$donate->handleDesignation(
			array(
				'id'		=> $designation_id,
				'amount'	=> $amount_total,
				'comment'	=> $short_description
			)
		);
	}



	// When the donate_id have a payment_id, it's means the current dedicate is finished ! Then, restart dedicate from scratch !
	public function donateMonitor()
	{
		if ($dedicate_id = $this->sessionGetDedicateID())
		{
			// Get any id. The first one for example...
			$dedicate_id = $dedicate_id[0];

			// Find the associated donate_id of the current dedicates (unique for all dedicate_id)
			global $db;
			$wcal_donate_id = $db->selectOne("wcal_dedicate, donate_id, where: id=$dedicate_id", 'donate_id');

			// Compare with the donate_id of the donate session
			$donate = new comDonate_();
			if ($donate->sessionGetDonateID() != $wcal_donate_id)
			{
				$this->sessionReset();
			}
		}
	}



	public function checkoutUrl( $view_only_designation = true )
	{
		$designation_id	= $this->getConfig('handle_designation_id');
		if (!$designation_id) {
			return;
		}

		if ($view_only_designation) {
			$addon = "&id=$designation_id";
		} else {
			$addon ='';
		}
		return comMenu_rewrite('com=donate&page=index'.$addon);
	}



	/*
	 * Quick method to know if a dedicate is validated or not
	 */

	public function paymentStatus( $dedicate_id )
	{
		global $db;
		$dedicate = $db->selectOne("wcal_dedicate, payment_status, donate_id, where: id=$dedicate_id");

		if (!$dedicate) {
			return NULL; # Invalid dedicate_id
		}

		if (!$dedicate['donate_id']) {
			return false; # No donate_id available (this case should not happen...)
		}

		/*
		 * First, check if the information is available in the 'payment_status' field.
		 * This field contain a copy (duplicate) of the payment status which is calculated from the payment component.
		 *
		 * It's difficult to get this information.
		 * Here is the thread : dedicate_id -> donate_id -> payment_id -> payment_x -> validated (where _x='_sips' for example)
		 *
		 * To keep high performances of the system, we create this duplicate 'payment_status' field.
		 */
		if (isset($dedicate['payment_status']))
		{
			if ($dedicate['payment_status'])
			{
				return true;
			} else {
				return false;
			}
		}
		// Second, the information still not available in the 'payment_status' field. So, check this manually...
		else
		{
			$donate = new comDonate_();
			if ($donate->checkDonation($dedicate['donate_id']))
			{
				return $donate->checkDonation_isPaymentValidated(); # Values : true, false or NULL if there is a problem
			} else {
				return false;
			}
		}
	}



	// Set the value of the 'payment_status' field for each dedicate which is validated or older than 3 days
	static public function updatePaymentStatus()
	{
		$count = 0;

		global $db;
		$dedicate = $db->select('wcal_dedicate, id,recording_date,donate_id, where: payment_status IS NULL');
		if (!$dedicate) {
			return $count;
		}

		$offset = 60*60*24*3; # 3 days
		$donate = new comDonate_();
		for ($i=0; $i<count($dedicate); $i++)
		{
			if ($dedicate[$i]['donate_id'] && $donate->checkDonation($dedicate[$i]['donate_id']) && $donate->checkDonation_isPaymentValidated()) {
				$payment_status = '1';
			}
			elseif ($dedicate[$i]['recording_date'] > time()-$offset) {
				continue; # This record is too recent. We are still waiting for a payment result...
			}
			else {
				$payment_status = '0';
			}
			$db->update("wcal_dedicate; payment_status=$payment_status; where: id=".$dedicate[$i]['id']);
			$count++;
		}

		return $count; # Return the number of updated lines
	}



	/*
	 * Match the content elements !
	 */

	static public function matchElement( $node_id, $elm_date_creation )
	{
		$match = array();

		$com_content = comContent_frontendScope();

		// List of subnodes from $node_id
		$node_id or $node_id == 0; # !important : Prevent the case $node_id === NULL;
		$nodes_id = array($node_id);
		$nodes = $com_content->getNodes($nodes_id[0]);
		for ($i=0; $i<count($nodes); $i++) {
			$nodes_id[] = $nodes[$i]['id'];
		}

		// Range of $elm_date_creation from 00:00 to 23:59
		$date = getdate($elm_date_creation);
		$time_begin	= mktime( 0, 0, 0, $date['mon'], $date['mday'], $date['year']);
		$time_end	= mktime(23,59,59, $date['mon'], $date['mday'], $date['year']);

		// Let's match by time !
		global $db;
		if ($element = $db->select("content_element, id,node_id, where: date_creation>=$time_begin AND, where: date_creation<=$time_end"))
		{
			for ($i=0; $i<count($element); $i++)
			{
				// Let's match by node !
				if (in_array($element[$i]['node_id'], $nodes_id))
				{
					$link = $com_content->elementUrlEncoder($element[$i]['id']);

					if ($com_content->pageUrlRequest())
					{
						$href = $com_content->pageUrlRequest().'&amp;'.$link['href'];
					} else {
						$href = $link['href'];
					}
					$href = comMenu_rewrite($href);

					$match[$element[$i]['id']] =
						array(
							'title'		=> $link['value'],
							'node'		=> $com_content->nodeFullPath($element[$i]['node_id']),
							'href'		=> $href,
							'visible'	=> $com_content->isVisibleElement($element[$i]['id'])
						);
				}
			}
		}

		return $match;
	}



	static public function matchDedicate( $element_id )
	{
		$match = array();

		global $db;
		if ($element = $db->selectOne("content_element, date_creation,node_id, where: id=$element_id"))
		{
			// Range of date_creation from 00:00 to 23:59
			$date = getdate($element['date_creation']);
			$time_begin	= mktime( 0, 0, 0, $date['mon'], $date['mday'], $date['year']);
			$time_end	= mktime(23,59,59, $date['mon'], $date['mday'], $date['year']);

			// Breadcrumb of node_id
			$node_id = $element['node_id'];
			$nodes = array($node_id);
			do {
				if ($parent_id = $db->selectOne("content_node, parent_id, where: id=$node_id", 'parent_id')) {
					$nodes[] = $node_id = $parent_id;
				}
			} while ($parent_id);

			self::updatePaymentStatus();
			$dedicate =
				$db->select(
					"wcal_dedicate_details, node_id, where: elm_date_creation>=$time_begin AND, where: elm_date_creation<=$time_end AND, join: dedicate_id>; ".
					"wcal_dedicate, id,recording_date(desc), event_date,type_id,comment, where: payment_status=1, join: <id"
				);

			for ($i=0; $i<count($dedicate); $i++)
			{
				if (in_array($dedicate[$i]['node_id'], $nodes) && !isset($match[$dedicate[$i]['id']]))
				{
					$match[$dedicate[$i]['id']] =
						array(
							'recording_date'	=> $dedicate[$i]['recording_date'	],
							'event_date'		=> $dedicate[$i]['event_date'		],
							'type_id'			=> $dedicate[$i]['type_id'			],
							'comment'			=> $dedicate[$i]['comment'			],
						);
				}
			}
		}

		return $match;
	}



	// This method performs a similar task than $this->matchDedicate(), but with others parameters
	static public function matchDedicateByTime( $time_begin = '', $time_end = '' )
	{
		$match = array();

		self::updatePaymentStatus();

		!$time_begin or $time_begin = "where: elm_date_creation>=$time_begin AND, ";
		!$time_end or $time_end = "where: elm_date_creation<=$time_end AND, ";

		global $db;
		$dedicate =
			$db->select(
				"wcal_dedicate_details, node_id,elm_date_creation, $time_begin{$time_end}join: dedicate_id>; ".
				"wcal_dedicate, id,recording_date(desc), event_date,type_id,comment, where: payment_status=1, join: <id"
			);

		for ($i=0; $i<count($dedicate); $i++)
		{
			$details =
				array(
					'node_id'			=> $dedicate[$i]['node_id'],
					'elm_date_creation'	=> $dedicate[$i]['elm_date_creation']
				);

			if (!isset($match[$dedicate[$i]['id']]))
			{
				$match[$dedicate[$i]['id']] =
					array(
						'details'			=> array($details), # Instead of the previous method, here is the addon
						'recording_date'	=> $dedicate[$i]['recording_date'	],
						'event_date'		=> $dedicate[$i]['event_date'		],
						'type_id'			=> $dedicate[$i]['type_id'			],
						'comment'			=> $dedicate[$i]['comment'			]
					);
			}
			else {
				$match[$dedicate[$i]['id']]['details'][] = $details;
			}
		}

		return $match;
	}



	/**
	 * @param array $match Return of $this->matchDedicate() of $this->matchDedicateByTime() methods
	 */
	static public function matchDedicateHTML( $match )
	{
		$html = '';

		$type = wcal::dedicateTypeOptions(false);

		$i = 0;
		foreach($match as $dedicate)
		{
			// Commons infos
			$recording_date	= getTime($dedicate['recording_date'], ($dedicate['recording_date']<time()-3600*24 ? 'time=0':''));
			$event_date		= getTime($dedicate['event_date'], 'format=long;time=no');
			$type_id		= $type[$dedicate['type_id']];
			$comment		= $dedicate['comment'];

			// Link to each element that contains the dedicate
			$links = array();
			if (isset($dedicate['details']))
			{
				$details = $dedicate['details'];
				for ($j=0; $j<count($details); $j++)
				{
					$elements = self::matchElement($details[$j]['node_id'], $details[$j]['elm_date_creation']);
					foreach($elements as $id => $elem)
					{
						if ($elem['visible']) {
							$links[$id] = '<a title="'.LANG_COM_WCAL_LIST_ELEMENT_LINK.'" href="'.$elem['href'].'">'.$elem['title'].'</a> ';
						}
					}
				}
			}
			$links = implode(' - ', $links);

			// Customize first and last comment...
			$class = '';
			if ($i == 0) {
				$class .= ' wcal-comment-first';
			}
			if ($i == count($match)-1) {
				$class .= ' wcal-comment-last';
			}

			// Get HTML
			$html .=
				"\t<div class=\"clearfix wcal-comment$class\">\n".
					($links ? "\t<p><strong>".LANG_COM_WCAL_LIST_ELEMENT_LINK." :</strong> $links </p>\n" : '').
					//"\t\t<h3>$type_id <span>$event_date </span></h3>\n". # Alternative version
					"\t\t<p>$comment </p>\n".
					"\t\t<h5>$type_id &nbsp;&middot;&nbsp; $event_date <span>".LANG_COM_WCAL_LIST_RECORDING_DATE." : $recording_date </span></h5>\n".
				"\t</div>\n";

			$i++;
		}

		return "\n\n<!-- wcal::dedicates (begin) -->\n<div class=\"wcal-comment-wrapper\">\n$html</div>\n<!-- wcal::dedicates (end) -->\n\n";
	}
}


?>